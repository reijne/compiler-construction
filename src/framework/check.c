
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isDeclaration (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundec) ||
	      (NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_globaldec) ||
	      (NODE_TYPE (arg_node) == N_globaldef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_num) ||
	      (NODE_TYPE (arg_node) == N_var));
  return (res);
}

static bool
isRetType (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_num) ||
	      (NODE_TYPE (arg_node) == N_void));
  return (res);
}

static bool
isStmt (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhile) ||
	      (NODE_TYPE (arg_node) == N_for) ||
	      (NODE_TYPE (arg_node) == N_if) ||
	      (NODE_TYPE (arg_node) == N_return) ||
	      (NODE_TYPE (arg_node) == N_while));
  return (res);
}

static bool
isType (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_num));
  return (res);
}

void
isDummy ()
{
  isDeclaration (NULL);
  isExpr (NULL);
  isRetType (NULL);
  isStmt (NULL);
  isType (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPR (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPR is NULL");
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_LET 
 */
  if ((FALSE) || (TRUE))
    {
      if (ASSIGN_LET (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_LET (arg_node)) == N_varlet)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_LET hasnt the right type."
					 " It should be: " "N_varlet");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_LET (arg_node), arg_node,
		   "attribute ASSIGN_LET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_LET (arg_node) != NULL)
    {
      ASSIGN_LET (arg_node) = TRAVdo (ASSIGN_LET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcomma
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Comma node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcomma (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcomma");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdeclarations
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Declarations node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdeclarations (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdeclarations");

/*
 * Son check: DECLARATIONS_DECLARATION 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "mandatory son DECLARATIONS_DECLARATION is NULL");
      if (DECLARATIONS_DECLARATION (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (isDeclaration (DECLARATIONS_DECLARATION (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_DECLARATION hasnt the right type."
					 " It should be: "
					 "Nodeset: Declaration");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_DECLARATION (arg_node), arg_node,
		   "attribute DECLARATIONS_DECLARATION must be NULL");
    }

/*
 * Son check: DECLARATIONS_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      if (DECLARATIONS_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DECLARATIONS_DECLARATIONS (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DECLARATIONS_DECLARATIONS hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (DECLARATIONS_DECLARATIONS (arg_node), arg_node,
		   "attribute DECLARATIONS_DECLARATIONS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_DECLARATION (arg_node) != NULL)
    {
      DECLARATIONS_DECLARATION (arg_node) =
	TRAVdo (DECLARATIONS_DECLARATION (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DECLARATIONS_DECLARATIONS (arg_node) != NULL)
    {
      DECLARATIONS_DECLARATIONS (arg_node) =
	TRAVdo (DECLARATIONS_DECLARATIONS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKextern
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Extern node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKextern (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKextern");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbodyblock
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBodyBlock node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbodyblock (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbodyblock");

/*
 * Son check: FUNBODYBLOCK_FUNBODY 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODYBLOCK_FUNBODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODYBLOCK_FUNBODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODYBLOCK_FUNBODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODYBLOCK_FUNBODY (arg_node), arg_node,
		   "attribute FUNBODYBLOCK_FUNBODY must be NULL");
    }

/*
 * Son check: FUNBODYBLOCK_L_CURLY_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODYBLOCK_L_CURLY_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODYBLOCK_L_CURLY_BRACKET (arg_node)) ==
		   N_l_curly_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODYBLOCK_L_CURLY_BRACKET hasnt the right type."
					 " It should be: "
					 "N_l_curly_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODYBLOCK_L_CURLY_BRACKET (arg_node), arg_node,
		   "attribute FUNBODYBLOCK_L_CURLY_BRACKET must be NULL");
    }

/*
 * Son check: FUNBODYBLOCK_R_CURLY_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNBODYBLOCK_R_CURLY_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNBODYBLOCK_R_CURLY_BRACKET (arg_node)) ==
		   N_r_curly_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNBODYBLOCK_R_CURLY_BRACKET hasnt the right type."
					 " It should be: "
					 "N_r_curly_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNBODYBLOCK_R_CURLY_BRACKET (arg_node), arg_node,
		   "attribute FUNBODYBLOCK_R_CURLY_BRACKET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODYBLOCK_FUNBODY (arg_node) != NULL)
    {
      FUNBODYBLOCK_FUNBODY (arg_node) =
	TRAVdo (FUNBODYBLOCK_FUNBODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODYBLOCK_L_CURLY_BRACKET (arg_node) != NULL)
    {
      FUNBODYBLOCK_L_CURLY_BRACKET (arg_node) =
	TRAVdo (FUNBODYBLOCK_L_CURLY_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNBODYBLOCK_R_CURLY_BRACKET (arg_node) != NULL)
    {
      FUNBODYBLOCK_R_CURLY_BRACKET (arg_node) =
	TRAVdo (FUNBODYBLOCK_R_CURLY_BRACKET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundec");

/*
 * Son check: FUNDEC_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEC_FUNHEADER is NULL");
      if (FUNDEC_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEC_FUNHEADER must be NULL");
    }

/*
 * Son check: FUNDEC_KEYWORD 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_KEYWORD (arg_node), arg_node,
		   "mandatory son FUNDEC_KEYWORD is NULL");
      if (FUNDEC_KEYWORD (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_KEYWORD (arg_node)) == N_extern)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_KEYWORD hasnt the right type."
					 " It should be: " "N_extern");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_KEYWORD (arg_node), arg_node,
		   "attribute FUNDEC_KEYWORD must be NULL");
    }

/*
 * Son check: FUNDEC_SEMICOLON 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_SEMICOLON (arg_node), arg_node,
		   "mandatory son FUNDEC_SEMICOLON is NULL");
      if (FUNDEC_SEMICOLON (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_SEMICOLON (arg_node)) == N_semicolon)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_SEMICOLON hasnt the right type."
					 " It should be: " "N_semicolon");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_SEMICOLON (arg_node), arg_node,
		   "attribute FUNDEC_SEMICOLON must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_FUNHEADER (arg_node) != NULL)
    {
      FUNDEC_FUNHEADER (arg_node) =
	TRAVdo (FUNDEC_FUNHEADER (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_KEYWORD (arg_node) != NULL)
    {
      FUNDEC_KEYWORD (arg_node) =
	TRAVdo (FUNDEC_KEYWORD (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_SEMICOLON (arg_node) != NULL)
    {
      FUNDEC_SEMICOLON (arg_node) =
	TRAVdo (FUNDEC_SEMICOLON (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundef");

/*
 * Son check: FUNDEF_FUNBODYBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_FUNBODYBLOCK (arg_node), arg_node,
		   "mandatory son FUNDEF_FUNBODYBLOCK is NULL");
      if (FUNDEF_FUNBODYBLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNBODYBLOCK (arg_node)) ==
		   N_funbodyblock)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNBODYBLOCK hasnt the right type."
					 " It should be: " "N_funbodyblock");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNBODYBLOCK (arg_node), arg_node,
		   "attribute FUNDEF_FUNBODYBLOCK must be NULL");
    }

/*
 * Son check: FUNDEF_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEF_FUNHEADER is NULL");
      if (FUNDEF_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEF_FUNHEADER must be NULL");
    }

/*
 * Son check: FUNDEF_KEYWORD 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_KEYWORD (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_KEYWORD (arg_node)) == N_export)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_KEYWORD hasnt the right type."
					 " It should be: " "N_export");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_KEYWORD (arg_node), arg_node,
		   "attribute FUNDEF_KEYWORD must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNBODYBLOCK (arg_node) != NULL)
    {
      FUNDEF_FUNBODYBLOCK (arg_node) =
	TRAVdo (FUNDEF_FUNBODYBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNHEADER (arg_node) != NULL)
    {
      FUNDEF_FUNHEADER (arg_node) =
	TRAVdo (FUNDEF_FUNHEADER (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_KEYWORD (arg_node) != NULL)
    {
      FUNDEF_KEYWORD (arg_node) =
	TRAVdo (FUNDEF_KEYWORD (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunheader
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunHeader node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunheader (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunheader");

/*
 * Son check: FUNHEADER_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_ID (arg_node), arg_node,
		   "mandatory son FUNHEADER_ID is NULL");
      if (FUNHEADER_ID (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_ID (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_ID hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_ID (arg_node), arg_node,
		   "attribute FUNHEADER_ID must be NULL");
    }

/*
 * Son check: FUNHEADER_L_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_L_BRACKET (arg_node), arg_node,
		   "mandatory son FUNHEADER_L_BRACKET is NULL");
      if (FUNHEADER_L_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_L_BRACKET (arg_node)) == N_export)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_L_BRACKET hasnt the right type."
					 " It should be: " "N_export");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_L_BRACKET (arg_node), arg_node,
		   "attribute FUNHEADER_L_BRACKET must be NULL");
    }

/*
 * Son check: FUNHEADER_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNHEADER_PARAMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_PARAMS (arg_node)) == N_params)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_PARAMS hasnt the right type."
					 " It should be: " "N_params");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_PARAMS (arg_node), arg_node,
		   "attribute FUNHEADER_PARAMS must be NULL");
    }

/*
 * Son check: FUNHEADER_R_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_R_BRACKET (arg_node), arg_node,
		   "mandatory son FUNHEADER_R_BRACKET is NULL");
      if (FUNHEADER_R_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_R_BRACKET (arg_node)) == N_export)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_R_BRACKET hasnt the right type."
					 " It should be: " "N_export");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_R_BRACKET (arg_node), arg_node,
		   "attribute FUNHEADER_R_BRACKET must be NULL");
    }

/*
 * Son check: FUNHEADER_RETTYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_RETTYPE (arg_node), arg_node,
		   "mandatory son FUNHEADER_RETTYPE is NULL");
      if (FUNHEADER_RETTYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isRetType (FUNHEADER_RETTYPE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_RETTYPE hasnt the right type."
					 " It should be: "
					 "Nodeset: RetType");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_RETTYPE (arg_node), arg_node,
		   "attribute FUNHEADER_RETTYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_ID (arg_node) != NULL)
    {
      FUNHEADER_ID (arg_node) = TRAVdo (FUNHEADER_ID (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_L_BRACKET (arg_node) != NULL)
    {
      FUNHEADER_L_BRACKET (arg_node) =
	TRAVdo (FUNHEADER_L_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_PARAMS (arg_node) != NULL)
    {
      FUNHEADER_PARAMS (arg_node) =
	TRAVdo (FUNHEADER_PARAMS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_R_BRACKET (arg_node) != NULL)
    {
      FUNHEADER_R_BRACKET (arg_node) =
	TRAVdo (FUNHEADER_R_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_RETTYPE (arg_node) != NULL)
    {
      FUNHEADER_RETTYPE (arg_node) =
	TRAVdo (FUNHEADER_RETTYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldec");

/*
 * Son check: GLOBALDEC_EXTERN 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_EXTERN (arg_node), arg_node,
		   "mandatory son GLOBALDEC_EXTERN is NULL");
      if (GLOBALDEC_EXTERN (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (GLOBALDEC_EXTERN (arg_node)) == N_extern)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_EXTERN hasnt the right type."
					 " It should be: " "N_extern");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_EXTERN (arg_node), arg_node,
		   "attribute GLOBALDEC_EXTERN must be NULL");
    }

/*
 * Son check: GLOBALDEC_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_ID (arg_node), arg_node,
		   "mandatory son GLOBALDEC_ID is NULL");
      if (GLOBALDEC_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEC_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_ID (arg_node), arg_node,
		   "attribute GLOBALDEC_ID must be NULL");
    }

/*
 * Son check: GLOBALDEC_SEMICOLON 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_SEMICOLON (arg_node), arg_node,
		   "mandatory son GLOBALDEC_SEMICOLON is NULL");
      if (GLOBALDEC_SEMICOLON (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (GLOBALDEC_SEMICOLON (arg_node)) ==
		   N_semicolon)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_SEMICOLON hasnt the right type."
					 " It should be: " "N_semicolon");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_SEMICOLON (arg_node), arg_node,
		   "attribute GLOBALDEC_SEMICOLON must be NULL");
    }

/*
 * Son check: GLOBALDEC_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_TYPE (arg_node), arg_node,
		   "mandatory son GLOBALDEC_TYPE is NULL");
      if (GLOBALDEC_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isType (GLOBALDEC_TYPE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_TYPE hasnt the right type."
					 " It should be: " "Nodeset: Type");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_TYPE (arg_node), arg_node,
		   "attribute GLOBALDEC_TYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_EXTERN (arg_node) != NULL)
    {
      GLOBALDEC_EXTERN (arg_node) =
	TRAVdo (GLOBALDEC_EXTERN (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_ID (arg_node) != NULL)
    {
      GLOBALDEC_ID (arg_node) = TRAVdo (GLOBALDEC_ID (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_SEMICOLON (arg_node) != NULL)
    {
      GLOBALDEC_SEMICOLON (arg_node) =
	TRAVdo (GLOBALDEC_SEMICOLON (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_TYPE (arg_node) != NULL)
    {
      GLOBALDEC_TYPE (arg_node) =
	TRAVdo (GLOBALDEC_TYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldef");

/*
 * Son check: GLOBALDEF_EXPORT 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPORT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (GLOBALDEF_EXPORT (arg_node)) == N_export)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPORT hasnt the right type."
					 " It should be: " "N_export");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPORT (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPORT must be NULL");
    }

/*
 * Son check: GLOBALDEF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBALDEF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPR (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPR must be NULL");
    }

/*
 * Son check: GLOBALDEF_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_ID (arg_node), arg_node,
		   "mandatory son GLOBALDEF_ID is NULL");
      if (GLOBALDEF_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEF_ID (arg_node)) == N_id)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_ID hasnt the right type."
					 " It should be: " "N_id");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_ID (arg_node), arg_node,
		   "attribute GLOBALDEF_ID must be NULL");
    }

/*
 * Son check: GLOBALDEF_SEMICOLON 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_SEMICOLON (arg_node), arg_node,
		   "mandatory son GLOBALDEF_SEMICOLON is NULL");
      if (GLOBALDEF_SEMICOLON (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (GLOBALDEF_SEMICOLON (arg_node)) ==
		   N_semicolon)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_SEMICOLON hasnt the right type."
					 " It should be: " "N_semicolon");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_SEMICOLON (arg_node), arg_node,
		   "attribute GLOBALDEF_SEMICOLON must be NULL");
    }

/*
 * Son check: GLOBALDEF_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_TYPE (arg_node), arg_node,
		   "mandatory son GLOBALDEF_TYPE is NULL");
      if (GLOBALDEF_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isType (GLOBALDEF_TYPE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_TYPE hasnt the right type."
					 " It should be: " "Nodeset: Type");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_TYPE (arg_node), arg_node,
		   "attribute GLOBALDEF_TYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPORT (arg_node) != NULL)
    {
      GLOBALDEF_EXPORT (arg_node) =
	TRAVdo (GLOBALDEF_EXPORT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPR (arg_node) != NULL)
    {
      GLOBALDEF_EXPR (arg_node) =
	TRAVdo (GLOBALDEF_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_ID (arg_node) != NULL)
    {
      GLOBALDEF_ID (arg_node) = TRAVdo (GLOBALDEF_ID (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_SEMICOLON (arg_node) != NULL)
    {
      GLOBALDEF_SEMICOLON (arg_node) =
	TRAVdo (GLOBALDEF_SEMICOLON (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_TYPE (arg_node) != NULL)
    {
      GLOBALDEF_TYPE (arg_node) =
	TRAVdo (GLOBALDEF_TYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKid
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Id node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKid (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKid");

/*
 * Attribute check: ID_ID
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ID_ID (arg_node), arg_node,
			 "mandatory attribute ID_ID is NULL");
    }
  else
    {
      CHKnotExist (ID_ID (arg_node), arg_node,
		   "attribute ID_ID must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKl_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node L_bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKl_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKl_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKl_curly_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node L_curly_bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKl_curly_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKl_curly_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmodule
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Module node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmodule (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmodule");

/*
 * Son check: MODULE_STMTS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MODULE_STMTS (arg_node), arg_node,
		   "mandatory son MODULE_STMTS is NULL");
      if (MODULE_STMTS (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (MODULE_STMTS (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MODULE_STMTS hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (MODULE_STMTS (arg_node), arg_node,
		   "attribute MODULE_STMTS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MODULE_STMTS (arg_node) != NULL)
    {
      MODULE_STMTS (arg_node) = TRAVdo (MODULE_STMTS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_RIGHT (arg_node), arg_node,
		   "mandatory son MONOP_RIGHT is NULL");
      if (MONOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (MONOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_RIGHT (arg_node), arg_node,
		   "attribute MONOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_RIGHT (arg_node) != NULL)
    {
      MONOP_RIGHT (arg_node) = TRAVdo (MONOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKnum (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKnum");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_ID 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAM_ID (arg_node), arg_node,
		   "mandatory son PARAM_ID is NULL");
      if (PARAM_ID (arg_node) != NULL)
	{
	  if (!((FALSE) || (isId (PARAM_ID (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_ID hasnt the right type."
					 " It should be: " "Nodeset: Id");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_ID (arg_node), arg_node,
		   "attribute PARAM_ID must be NULL");
    }

/*
 * Son check: PARAM_RETTYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAM_RETTYPE (arg_node), arg_node,
		   "mandatory son PARAM_RETTYPE is NULL");
      if (PARAM_RETTYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isRetType (PARAM_RETTYPE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_RETTYPE hasnt the right type."
					 " It should be: "
					 "Nodeset: RetType");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_RETTYPE (arg_node), arg_node,
		   "attribute PARAM_RETTYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_ID (arg_node) != NULL)
    {
      PARAM_ID (arg_node) = TRAVdo (PARAM_ID (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_RETTYPE (arg_node) != NULL)
    {
      PARAM_RETTYPE (arg_node) = TRAVdo (PARAM_RETTYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparams
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Params node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparams (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparams");

/*
 * Son check: PARAMS_COMMA 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAMS_COMMA (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAMS_COMMA (arg_node)) == N_comma)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMS_COMMA hasnt the right type."
					 " It should be: " "N_comma");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMS_COMMA (arg_node), arg_node,
		   "attribute PARAMS_COMMA must be NULL");
    }

/*
 * Son check: PARAMS_PARAM 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAMS_PARAM (arg_node), arg_node,
		   "mandatory son PARAMS_PARAM is NULL");
      if (PARAMS_PARAM (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAMS_PARAM (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMS_PARAM hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMS_PARAM (arg_node), arg_node,
		   "attribute PARAMS_PARAM must be NULL");
    }

/*
 * Son check: PARAMS_PARAMS 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAMS_PARAMS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (PARAMS_PARAMS (arg_node)) == N_params)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMS_PARAMS hasnt the right type."
					 " It should be: " "N_params");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMS_PARAMS (arg_node), arg_node,
		   "attribute PARAMS_PARAMS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMS_COMMA (arg_node) != NULL)
    {
      PARAMS_COMMA (arg_node) = TRAVdo (PARAMS_COMMA (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMS_PARAM (arg_node) != NULL)
    {
      PARAMS_PARAM (arg_node) = TRAVdo (PARAMS_PARAM (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMS_PARAMS (arg_node) != NULL)
    {
      PARAMS_PARAMS (arg_node) = TRAVdo (PARAMS_PARAMS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKprogram (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKprogram");

/*
 * Son check: PROGRAM_DECLARATIONS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "mandatory son PROGRAM_DECLARATIONS is NULL");
      if (PROGRAM_DECLARATIONS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PROGRAM_DECLARATIONS (arg_node)) ==
		   N_declarations)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_DECLARATIONS hasnt the right type."
					 " It should be: " "N_declarations");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_DECLARATIONS (arg_node), arg_node,
		   "attribute PROGRAM_DECLARATIONS must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_DECLARATIONS (arg_node) != NULL)
    {
      PROGRAM_DECLARATIONS (arg_node) =
	TRAVdo (PROGRAM_DECLARATIONS (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKr_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node R_bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKr_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKr_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKr_curly_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node R_curly_bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKr_curly_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKr_curly_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsemicolon
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Semicolon node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsemicolon (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsemicolon");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstmts
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Stmts node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstmts (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstmts");

/*
 * Son check: STMTS_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STMTS_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (STMTS_NEXT (arg_node)) == N_stmts)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_NEXT hasnt the right type."
					 " It should be: " "N_stmts");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_NEXT (arg_node), arg_node,
		   "attribute STMTS_NEXT must be NULL");
    }

/*
 * Son check: STMTS_STMT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STMTS_STMT (arg_node), arg_node,
		   "mandatory son STMTS_STMT is NULL");
      if (STMTS_STMT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isStmt (STMTS_STMT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STMTS_STMT hasnt the right type."
					 " It should be: " "Nodeset: Stmt");
	    }
	}
    }
  else
    {
      CHKnotExist (STMTS_STMT (arg_node), arg_node,
		   "attribute STMTS_STMT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_NEXT (arg_node) != NULL)
    {
      STMTS_NEXT (arg_node) = TRAVdo (STMTS_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STMTS_STMT (arg_node) != NULL)
    {
      STMTS_STMT (arg_node) = TRAVdo (STMTS_STMT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKsymboltableentry
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node SymbolTableEntry node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKsymboltableentry (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKsymboltableentry");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvar (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvar");

/*
 * Attribute check: VAR_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VAR_DECL (arg_node), arg_node,
		   "attribute VAR_DECL must be NULL");
    }

/*
 * Attribute check: VAR_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VAR_NAME (arg_node), arg_node,
			 "mandatory attribute VAR_NAME is NULL");
    }
  else
    {
      CHKnotExist (VAR_NAME (arg_node), arg_node,
		   "attribute VAR_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvarlet
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarLet node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvarlet (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvarlet");

/*
 * Attribute check: VARLET_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VARLET_DECL (arg_node), arg_node,
		   "attribute VARLET_DECL must be NULL");
    }

/*
 * Attribute check: VARLET_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARLET_NAME (arg_node), arg_node,
			 "mandatory attribute VARLET_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARLET_NAME (arg_node), arg_node,
		   "attribute VARLET_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_error_message,
  CHK_float_value,
  CHK_id_id,
  CHK_module_count_all,
  CHK_monop_op,
  CHK_num_value,
  CHK_var_name,
  CHK_varlet_name
} attr_list;
