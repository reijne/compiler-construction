
/**
 * @file node_basic.c
 *
 * Functions to allocate node structures
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: node_basic.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "node_basic.h"
#include "tree_basic.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "ctinfo.h"

static node *
MakeEmptyNode ()
{
  node *result;

  DBUG_ENTER ("MakeEmptyNode");

  result = (node *) MEMmalloc (sizeof (node));

  NODE_LINE (result) = global.line;
  NODE_COL (result) = global.col;

  DBUG_RETURN (result);
}



/*****************************************************************************
 * N_Program :
 *****************************************************************************/

node *
TBmakeProgram (node * Declarations)
{
  node *this;
  DBUG_ENTER ("TBmakeProgram");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_program = MEMmalloc (sizeof (struct SONS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_program = MEMmalloc (sizeof (struct ATTRIBS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declarations initial value: %s ",
	       Declarations));
  PROGRAM_DECLARATIONS (this) = Declarations;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PROGRAM_DECLARATIONS (this) != NULL)
      && (NODE_TYPE (PROGRAM_DECLARATIONS (this)) != N_declarations))
    {
      CTIwarn
	("Field Declarations of node N_Program has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Declarations :
 *****************************************************************************/

node *
TBmakeDeclarations (node * Declaration, node * Declarations)
{
  node *this;
  DBUG_ENTER ("TBmakeDeclarations");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_declarations;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_declarations = MEMmalloc (sizeof (struct SONS_N_DECLARATIONS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_declarations =
    MEMmalloc (sizeof (struct ATTRIBS_N_DECLARATIONS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_declarations;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declaration initial value: %s ", Declaration));
  DECLARATIONS_DECLARATION (this) = Declaration;
  DBUG_PRINT ("MAKE",
	      ("assigning son Declarations initial value: %s ",
	       Declarations));
  DECLARATIONS_DECLARATIONS (this) = Declarations;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DECLARATIONS_DECLARATION (this) != NULL)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_fundec)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_fundef)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_globaldec)
      && (NODE_TYPE (DECLARATIONS_DECLARATION (this)) != N_globaldef))
    {
      CTIwarn
	("Field Declaration of node N_Declarations has non-allowed target node.");
    }
  if ((DECLARATIONS_DECLARATIONS (this) != NULL)
      && (NODE_TYPE (DECLARATIONS_DECLARATIONS (this)) != N_declarations))
    {
      CTIwarn
	("Field Declarations of node N_Declarations has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Module :
 *****************************************************************************/

node *
TBmakeModule (int Count_all, int Count_add, int Count_sub, int Count_mul,
	      int Count_div, int Count_mod, node * Stmts)
{
  node *this;
  DBUG_ENTER ("TBmakeModule");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_module;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_module = MEMmalloc (sizeof (struct SONS_N_MODULE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_module = MEMmalloc (sizeof (struct ATTRIBS_N_MODULE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_module;
  DBUG_PRINT ("MAKE", ("assigning son Stmts initial value: %s ", Stmts));
  MODULE_STMTS (this) = Stmts;
  MODULE_COUNT_ALL (this) = Count_all;
  MODULE_COUNT_ADD (this) = Count_add;
  MODULE_COUNT_SUB (this) = Count_sub;
  MODULE_COUNT_MUL (this) = Count_mul;
  MODULE_COUNT_DIV (this) = Count_div;
  MODULE_COUNT_MOD (this) = Count_mod;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MODULE_STMTS (this) != NULL)
      && (NODE_TYPE (MODULE_STMTS (this)) != N_stmts))
    {
      CTIwarn ("Field Stmts of node N_Module has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDec :
 *****************************************************************************/

node *
TBmakeFundec (node * Keyword, node * FunHeader, node * Semicolon)
{
  node *this;
  DBUG_ENTER ("TBmakeFundec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundec = MEMmalloc (sizeof (struct SONS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundec = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("assigning son Keyword initial value: %s ", Keyword));
  FUNDEC_KEYWORD (this) = Keyword;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunHeader initial value: %s ", FunHeader));
  FUNDEC_FUNHEADER (this) = FunHeader;
  DBUG_PRINT ("MAKE",
	      ("assigning son Semicolon initial value: %s ", Semicolon));
  FUNDEC_SEMICOLON (this) = Semicolon;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEC_KEYWORD (this) != NULL)
      && (NODE_TYPE (FUNDEC_KEYWORD (this)) != N_extern))
    {
      CTIwarn ("Field Keyword of node N_FunDec has non-allowed target node.");
    }
  if ((FUNDEC_FUNHEADER (this) != NULL)
      && (NODE_TYPE (FUNDEC_FUNHEADER (this)) != N_funheader))
    {
      CTIwarn
	("Field FunHeader of node N_FunDec has non-allowed target node.");
    }
  if ((FUNDEC_SEMICOLON (this) != NULL)
      && (NODE_TYPE (FUNDEC_SEMICOLON (this)) != N_semicolon))
    {
      CTIwarn
	("Field Semicolon of node N_FunDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Extern :
 *****************************************************************************/

node *
TBmakeExtern ()
{
  node *this;
  DBUG_ENTER ("TBmakeExtern");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_extern;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_extern = MEMmalloc (sizeof (struct SONS_N_EXTERN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_extern = MEMmalloc (sizeof (struct ATTRIBS_N_EXTERN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_extern;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Semicolon :
 *****************************************************************************/

node *
TBmakeSemicolon ()
{
  node *this;
  DBUG_ENTER ("TBmakeSemicolon");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_semicolon;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_semicolon = MEMmalloc (sizeof (struct SONS_N_SEMICOLON));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_semicolon = MEMmalloc (sizeof (struct ATTRIBS_N_SEMICOLON));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_semicolon;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDef :
 *****************************************************************************/

node *
TBmakeFundef (node * Keyword, node * FunHeader, node * FunBodyBlock)
{
  node *this;
  DBUG_ENTER ("TBmakeFundef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundef = MEMmalloc (sizeof (struct SONS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundef = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("assigning son Keyword initial value: %s ", Keyword));
  FUNDEF_KEYWORD (this) = Keyword;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunHeader initial value: %s ", FunHeader));
  FUNDEF_FUNHEADER (this) = FunHeader;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunBodyBlock initial value: %s ",
	       FunBodyBlock));
  FUNDEF_FUNBODYBLOCK (this) = FunBodyBlock;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEF_KEYWORD (this) != NULL)
      && (NODE_TYPE (FUNDEF_KEYWORD (this)) != N_export))
    {
      CTIwarn ("Field Keyword of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_FUNHEADER (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNHEADER (this)) != N_funheader))
    {
      CTIwarn
	("Field FunHeader of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_FUNBODYBLOCK (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNBODYBLOCK (this)) != N_funbodyblock))
    {
      CTIwarn
	("Field FunBodyBlock of node N_FunDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunBodyBlock :
 *****************************************************************************/

node *
TBmakeFunbodyblock (node * L_curly_bracket, node * FunBody,
		    node * R_curly_bracket)
{
  node *this;
  DBUG_ENTER ("TBmakeFunbodyblock");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funbodyblock;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funbodyblock = MEMmalloc (sizeof (struct SONS_N_FUNBODYBLOCK));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funbodyblock =
    MEMmalloc (sizeof (struct ATTRIBS_N_FUNBODYBLOCK));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funbodyblock;
  DBUG_PRINT ("MAKE",
	      ("assigning son L_curly_bracket initial value: %s ",
	       L_curly_bracket));
  FUNBODYBLOCK_L_CURLY_BRACKET (this) = L_curly_bracket;
  DBUG_PRINT ("MAKE", ("assigning son FunBody initial value: %s ", FunBody));
  FUNBODYBLOCK_FUNBODY (this) = FunBody;
  DBUG_PRINT ("MAKE",
	      ("assigning son R_curly_bracket initial value: %s ",
	       R_curly_bracket));
  FUNBODYBLOCK_R_CURLY_BRACKET (this) = R_curly_bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNBODYBLOCK_L_CURLY_BRACKET (this) != NULL)
      && (NODE_TYPE (FUNBODYBLOCK_L_CURLY_BRACKET (this)) !=
	  N_l_curly_bracket))
    {
      CTIwarn
	("Field L_curly_bracket of node N_FunBodyBlock has non-allowed target node.");
    }
  if ((FUNBODYBLOCK_FUNBODY (this) != NULL)
      && (NODE_TYPE (FUNBODYBLOCK_FUNBODY (this)) != N_funbody))
    {
      CTIwarn
	("Field FunBody of node N_FunBodyBlock has non-allowed target node.");
    }
  if ((FUNBODYBLOCK_R_CURLY_BRACKET (this) != NULL)
      && (NODE_TYPE (FUNBODYBLOCK_R_CURLY_BRACKET (this)) !=
	  N_r_curly_bracket))
    {
      CTIwarn
	("Field R_curly_bracket of node N_FunBodyBlock has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_L_curly_bracket :
 *****************************************************************************/

node *
TBmakeL_curly_bracket ()
{
  node *this;
  DBUG_ENTER ("TBmakeL_curly_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_l_curly_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_l_curly_bracket =
    MEMmalloc (sizeof (struct SONS_N_L_CURLY_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_l_curly_bracket =
    MEMmalloc (sizeof (struct ATTRIBS_N_L_CURLY_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_l_curly_bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_R_curly_bracket :
 *****************************************************************************/

node *
TBmakeR_curly_bracket ()
{
  node *this;
  DBUG_ENTER ("TBmakeR_curly_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_r_curly_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_r_curly_bracket =
    MEMmalloc (sizeof (struct SONS_N_R_CURLY_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_r_curly_bracket =
    MEMmalloc (sizeof (struct ATTRIBS_N_R_CURLY_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_r_curly_bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_L_bracket :
 *****************************************************************************/

node *
TBmakeL_bracket ()
{
  node *this;
  DBUG_ENTER ("TBmakeL_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_l_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_l_bracket = MEMmalloc (sizeof (struct SONS_N_L_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_l_bracket = MEMmalloc (sizeof (struct ATTRIBS_N_L_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_l_bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_R_bracket :
 *****************************************************************************/

node *
TBmakeR_bracket ()
{
  node *this;
  DBUG_ENTER ("TBmakeR_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_r_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_r_bracket = MEMmalloc (sizeof (struct SONS_N_R_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_r_bracket = MEMmalloc (sizeof (struct ATTRIBS_N_R_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_r_bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Comma :
 *****************************************************************************/

node *
TBmakeComma ()
{
  node *this;
  DBUG_ENTER ("TBmakeComma");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_comma;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_comma = MEMmalloc (sizeof (struct SONS_N_COMMA));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_comma = MEMmalloc (sizeof (struct ATTRIBS_N_COMMA));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_comma;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunHeader :
 *****************************************************************************/

node *
TBmakeFunheader (node * RetType, node * Id, node * L_bracket, node * Params,
		 node * R_bracket)
{
  node *this;
  DBUG_ENTER ("TBmakeFunheader");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funheader;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funheader = MEMmalloc (sizeof (struct SONS_N_FUNHEADER));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funheader = MEMmalloc (sizeof (struct ATTRIBS_N_FUNHEADER));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funheader;
  DBUG_PRINT ("MAKE", ("assigning son RetType initial value: %s ", RetType));
  FUNHEADER_RETTYPE (this) = RetType;
  DBUG_PRINT ("MAKE", ("assigning son Id initial value: %s ", Id));
  FUNHEADER_ID (this) = Id;
  DBUG_PRINT ("MAKE",
	      ("assigning son L_bracket initial value: %s ", L_bracket));
  FUNHEADER_L_BRACKET (this) = L_bracket;
  DBUG_PRINT ("MAKE", ("assigning son Params initial value: %s ", Params));
  FUNHEADER_PARAMS (this) = Params;
  DBUG_PRINT ("MAKE",
	      ("assigning son R_bracket initial value: %s ", R_bracket));
  FUNHEADER_R_BRACKET (this) = R_bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNHEADER_RETTYPE (this) != NULL)
      && (NODE_TYPE (FUNHEADER_RETTYPE (this)) != N_void)
      && (NODE_TYPE (FUNHEADER_RETTYPE (this)) != N_num)
      && (NODE_TYPE (FUNHEADER_RETTYPE (this)) != N_float)
      && (NODE_TYPE (FUNHEADER_RETTYPE (this)) != N_bool))
    {
      CTIwarn
	("Field RetType of node N_FunHeader has non-allowed target node.");
    }
  if ((FUNHEADER_ID (this) != NULL)
      && (NODE_TYPE (FUNHEADER_ID (this)) != N_funheader))
    {
      CTIwarn ("Field Id of node N_FunHeader has non-allowed target node.");
    }
  if ((FUNHEADER_L_BRACKET (this) != NULL)
      && (NODE_TYPE (FUNHEADER_L_BRACKET (this)) != N_export))
    {
      CTIwarn
	("Field L_bracket of node N_FunHeader has non-allowed target node.");
    }
  if ((FUNHEADER_PARAMS (this) != NULL)
      && (NODE_TYPE (FUNHEADER_PARAMS (this)) != N_params))
    {
      CTIwarn
	("Field Params of node N_FunHeader has non-allowed target node.");
    }
  if ((FUNHEADER_R_BRACKET (this) != NULL)
      && (NODE_TYPE (FUNHEADER_R_BRACKET (this)) != N_export))
    {
      CTIwarn
	("Field R_bracket of node N_FunHeader has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Params :
 *****************************************************************************/

node *
TBmakeParams (node * Param, node * Comma, node * Params)
{
  node *this;
  DBUG_ENTER ("TBmakeParams");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_params;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_params = MEMmalloc (sizeof (struct SONS_N_PARAMS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_params = MEMmalloc (sizeof (struct ATTRIBS_N_PARAMS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_params;
  DBUG_PRINT ("MAKE", ("assigning son Param initial value: %s ", Param));
  PARAMS_PARAM (this) = Param;
  DBUG_PRINT ("MAKE", ("assigning son Comma initial value: %s ", Comma));
  PARAMS_COMMA (this) = Comma;
  DBUG_PRINT ("MAKE", ("assigning son Params initial value: %s ", Params));
  PARAMS_PARAMS (this) = Params;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PARAMS_PARAM (this) != NULL)
      && (NODE_TYPE (PARAMS_PARAM (this)) != N_param))
    {
      CTIwarn ("Field Param of node N_Params has non-allowed target node.");
    }
  if ((PARAMS_COMMA (this) != NULL)
      && (NODE_TYPE (PARAMS_COMMA (this)) != N_comma))
    {
      CTIwarn ("Field Comma of node N_Params has non-allowed target node.");
    }
  if ((PARAMS_PARAMS (this) != NULL)
      && (NODE_TYPE (PARAMS_PARAMS (this)) != N_params))
    {
      CTIwarn ("Field Params of node N_Params has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Param :
 *****************************************************************************/

node *
TBmakeParam (node * RetType, node * Id)
{
  node *this;
  DBUG_ENTER ("TBmakeParam");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_param = MEMmalloc (sizeof (struct SONS_N_PARAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_param = MEMmalloc (sizeof (struct ATTRIBS_N_PARAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("assigning son RetType initial value: %s ", RetType));
  PARAM_RETTYPE (this) = RetType;
  DBUG_PRINT ("MAKE", ("assigning son Id initial value: %s ", Id));
  PARAM_ID (this) = Id;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PARAM_RETTYPE (this) != NULL)
      && (NODE_TYPE (PARAM_RETTYPE (this)) != N_void)
      && (NODE_TYPE (PARAM_RETTYPE (this)) != N_num)
      && (NODE_TYPE (PARAM_RETTYPE (this)) != N_float)
      && (NODE_TYPE (PARAM_RETTYPE (this)) != N_bool))
    {
      CTIwarn ("Field RetType of node N_Param has non-allowed target node.");
    }
  if ((PARAM_ID (this) != NULL))
    {
      CTIwarn ("Field Id of node N_Param has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Id :
 *****************************************************************************/

node *
TBmakeId (char *Id)
{
  node *this;
  DBUG_ENTER ("TBmakeId");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_id;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_id = MEMmalloc (sizeof (struct SONS_N_ID));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_id = MEMmalloc (sizeof (struct ATTRIBS_N_ID));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_id;
  ID_ID (this) = Id;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobalDec :
 *****************************************************************************/

node *
TBmakeGlobaldec (node * Extern, node * Type, node * Id, node * Semicolon)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobaldec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globaldec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globaldec = MEMmalloc (sizeof (struct SONS_N_GLOBALDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globaldec = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBALDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globaldec;
  DBUG_PRINT ("MAKE", ("assigning son Extern initial value: %s ", Extern));
  GLOBALDEC_EXTERN (this) = Extern;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  GLOBALDEC_TYPE (this) = Type;
  DBUG_PRINT ("MAKE", ("assigning son Id initial value: %s ", Id));
  GLOBALDEC_ID (this) = Id;
  DBUG_PRINT ("MAKE",
	      ("assigning son Semicolon initial value: %s ", Semicolon));
  GLOBALDEC_SEMICOLON (this) = Semicolon;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBALDEC_EXTERN (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_EXTERN (this)) != N_extern))
    {
      CTIwarn
	("Field Extern of node N_GlobalDec has non-allowed target node.");
    }
  if ((GLOBALDEC_TYPE (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_TYPE (this)) != N_num)
      && (NODE_TYPE (GLOBALDEC_TYPE (this)) != N_float)
      && (NODE_TYPE (GLOBALDEC_TYPE (this)) != N_bool))
    {
      CTIwarn ("Field Type of node N_GlobalDec has non-allowed target node.");
    }
  if ((GLOBALDEC_ID (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_ID (this)) != N_id))
    {
      CTIwarn ("Field Id of node N_GlobalDec has non-allowed target node.");
    }
  if ((GLOBALDEC_SEMICOLON (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_SEMICOLON (this)) != N_semicolon))
    {
      CTIwarn
	("Field Semicolon of node N_GlobalDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobalDef :
 *****************************************************************************/

node *
TBmakeGlobaldef (node * Export, node * Type, node * Id, node * Expr,
		 node * Semicolon)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobaldef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globaldef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globaldef = MEMmalloc (sizeof (struct SONS_N_GLOBALDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globaldef = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBALDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globaldef;
  DBUG_PRINT ("MAKE", ("assigning son Export initial value: %s ", Export));
  GLOBALDEF_EXPORT (this) = Export;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  GLOBALDEF_TYPE (this) = Type;
  DBUG_PRINT ("MAKE", ("assigning son Id initial value: %s ", Id));
  GLOBALDEF_ID (this) = Id;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  GLOBALDEF_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE",
	      ("assigning son Semicolon initial value: %s ", Semicolon));
  GLOBALDEF_SEMICOLON (this) = Semicolon;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBALDEF_EXPORT (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_EXPORT (this)) != N_export))
    {
      CTIwarn
	("Field Export of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_TYPE (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_TYPE (this)) != N_num)
      && (NODE_TYPE (GLOBALDEF_TYPE (this)) != N_float)
      && (NODE_TYPE (GLOBALDEF_TYPE (this)) != N_bool))
    {
      CTIwarn ("Field Type of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_ID (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_ID (this)) != N_id))
    {
      CTIwarn ("Field Id of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_EXPR (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_binop)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_monop)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_var)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_num)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_float)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_bool))
    {
      CTIwarn ("Field Expr of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_SEMICOLON (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_SEMICOLON (this)) != N_semicolon))
    {
      CTIwarn
	("Field Semicolon of node N_GlobalDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Stmts :
 *****************************************************************************/

node *
TBmakeStmts (node * Stmt, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeStmts");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_stmts;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_stmts = MEMmalloc (sizeof (struct SONS_N_STMTS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_stmts = MEMmalloc (sizeof (struct ATTRIBS_N_STMTS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_stmts;
  DBUG_PRINT ("MAKE", ("assigning son Stmt initial value: %s ", Stmt));
  STMTS_STMT (this) = Stmt;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  STMTS_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((STMTS_STMT (this) != NULL)
      && (NODE_TYPE (STMTS_STMT (this)) != N_assign)
      && (NODE_TYPE (STMTS_STMT (this)) != N_if)
      && (NODE_TYPE (STMTS_STMT (this)) != N_while)
      && (NODE_TYPE (STMTS_STMT (this)) != N_dowhile)
      && (NODE_TYPE (STMTS_STMT (this)) != N_for)
      && (NODE_TYPE (STMTS_STMT (this)) != N_return))
    {
      CTIwarn ("Field Stmt of node N_Stmts has non-allowed target node.");
    }
  if ((STMTS_NEXT (this) != NULL)
      && (NODE_TYPE (STMTS_NEXT (this)) != N_stmts))
    {
      CTIwarn ("Field Next of node N_Stmts has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Assign :
 *****************************************************************************/

node *
TBmakeAssign (node * Let, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeAssign");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_assign = MEMmalloc (sizeof (struct SONS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_assign = MEMmalloc (sizeof (struct ATTRIBS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("assigning son Let initial value: %s ", Let));
  ASSIGN_LET (this) = Let;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  ASSIGN_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ASSIGN_LET (this) != NULL)
      && (NODE_TYPE (ASSIGN_LET (this)) != N_varlet))
    {
      CTIwarn ("Field Let of node N_Assign has non-allowed target node.");
    }
  if ((ASSIGN_EXPR (this) != NULL)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_binop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_monop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_var)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_num)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_float)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_bool))
    {
      CTIwarn ("Field Expr of node N_Assign has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_BinOp :
 *****************************************************************************/

node *
TBmakeBinop (binop Op, node * Left, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeBinop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_binop = MEMmalloc (sizeof (struct SONS_N_BINOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_binop = MEMmalloc (sizeof (struct ATTRIBS_N_BINOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("assigning son Left initial value: %s ", Left));
  BINOP_LEFT (this) = Left;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  BINOP_RIGHT (this) = Right;
  BINOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BINOP_LEFT (this) != NULL)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_binop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_monop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_var)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_num)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_float)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_bool))
    {
      CTIwarn ("Field Left of node N_BinOp has non-allowed target node.");
    }
  if ((BINOP_RIGHT (this) != NULL)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_var)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_num)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_float)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_bool))
    {
      CTIwarn ("Field Right of node N_BinOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_MonOp :
 *****************************************************************************/

node *
TBmakeMonop (monop Op, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeMonop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_monop = MEMmalloc (sizeof (struct SONS_N_MONOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_monop = MEMmalloc (sizeof (struct ATTRIBS_N_MONOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  MONOP_RIGHT (this) = Right;
  MONOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MONOP_RIGHT (this) != NULL)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_var)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_num)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_float)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_bool))
    {
      CTIwarn ("Field Right of node N_MonOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarLet :
 *****************************************************************************/

node *
TBmakeVarlet (char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeVarlet");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_varlet;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_varlet = MEMmalloc (sizeof (struct SONS_N_VARLET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_varlet = MEMmalloc (sizeof (struct ATTRIBS_N_VARLET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_varlet;
  VARLET_NAME (this) = Name;
  VARLET_DECL (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Var :
 *****************************************************************************/

node *
TBmakeVar (char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeVar");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_var;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_var = MEMmalloc (sizeof (struct SONS_N_VAR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_var = MEMmalloc (sizeof (struct ATTRIBS_N_VAR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_var;
  VAR_NAME (this) = Name;
  VAR_DECL (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Num :
 *****************************************************************************/

node *
TBmakeNum (int Value)
{
  node *this;
  DBUG_ENTER ("TBmakeNum");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_num;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_num = MEMmalloc (sizeof (struct SONS_N_NUM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_num = MEMmalloc (sizeof (struct ATTRIBS_N_NUM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_num;
  NUM_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Float :
 *****************************************************************************/

node *
TBmakeFloat (float Value)
{
  node *this;
  DBUG_ENTER ("TBmakeFloat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_float;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_float = MEMmalloc (sizeof (struct SONS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_float = MEMmalloc (sizeof (struct ATTRIBS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_float;
  FLOAT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Bool :
 *****************************************************************************/

node *
TBmakeBool (bool Value)
{
  node *this;
  DBUG_ENTER ("TBmakeBool");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_bool;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_bool = MEMmalloc (sizeof (struct SONS_N_BOOL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_bool = MEMmalloc (sizeof (struct ATTRIBS_N_BOOL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_bool;
  BOOL_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_SymbolTableEntry :
 *****************************************************************************/

node *
TBmakeSymboltableentry ()
{
  node *this;
  DBUG_ENTER ("TBmakeSymboltableentry");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_symboltableentry;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_symboltableentry =
    MEMmalloc (sizeof (struct SONS_N_SYMBOLTABLEENTRY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_symboltableentry =
    MEMmalloc (sizeof (struct ATTRIBS_N_SYMBOLTABLEENTRY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_symboltableentry;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Error :
 *****************************************************************************/

node *
TBmakeError (char *message, compiler_phase_t anyphase, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeError");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_error = MEMmalloc (sizeof (struct SONS_N_ERROR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_error = MEMmalloc (sizeof (struct ATTRIBS_N_ERROR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  ERROR_NEXT (this) = Next;
  ERROR_MESSAGE (this) = message;
  ERROR_ANYPHASE (this) = anyphase;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ERROR_NEXT (this) != NULL)
      && (NODE_TYPE (ERROR_NEXT (this)) != N_error))
    {
      CTIwarn ("Field Next of node N_Error has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

  /* end of file */
